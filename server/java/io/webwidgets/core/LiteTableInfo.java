package io.webwidgets.core; 

import java.io.*; 
import java.util.*; 
import java.sql.*; 

import java.util.regex.Pattern;
import java.util.regex.Matcher;

import javax.servlet.http.HttpServletRequest;
import org.json.simple.JSONObject;


import net.danburfoot.shared.Util;
import net.danburfoot.shared.CoreDb;
import net.danburfoot.shared.ArgMap;
import net.danburfoot.shared.CollUtil;
import net.danburfoot.shared.FileUtils;

import net.danburfoot.shared.CollUtil.*;
import net.danburfoot.shared.CoreDb.QueryCollector;
import net.danburfoot.shared.CoreDb.ConnectionSource;


import io.webwidgets.core.CoreUtil.*;
import io.webwidgets.core.WidgetOrg.*;

/**
 * Metadata about an underlying SQLite table
 * This class is used by the JS Code Generator to create the wrapper code that gets sent to the browser
 * This information is primarily generated by doing a SELECT * LIMIT 1 on the table and then examining
 * the ResultSetMetaData
 */
public class LiteTableInfo
{

    public static final Pattern BASIC_TABLE_MATCH = Pattern.compile("CREATE TABLE \"?(\\w+)\"?\\s*\\((.*?)\\)$");

    public static final Pattern DEFAULT_PATTERN = Pattern.compile("DEFAULT\\s+(?:(?:'([^']*)')|(\\d+(?:\\.\\d+)?)(?=\\s|,|$)|(\\w+))", Pattern.CASE_INSENSITIVE);


    public static final Pattern SIMPLE_STRING_OKAY = Pattern.compile("^[A-Za-z0-9]+$");

	public static final String LOAD_SUCCESS_TAG = LiteTableInfo.class.getSimpleName() + "__LOAD_SUCCESS";
	
	public static final String DECODE_URI_SHORTHAND = "__duric";
	
	public static final Set<String> SQLITE_STR_TYPE = Util.setify("varchar", "text");
	
	public enum ExchangeType
	{
		smallint,
		m_int("int"),
		real,
		m_double("double"),
		text,
		varchar;
		
		final String lookupTag;
		
		ExchangeType(String s)
		{
			lookupTag = s == null ? this.toString() : s;
		}
		
		ExchangeType()
		{
			this(null);
		}
	
		public static ExchangeType lookupFromSql(String scolname)
		{
			Set<ExchangeType> hits = Util.filter2set(ExchangeType.values(), et -> scolname.toLowerCase().contains(et.lookupTag));
			
			// Will hit both smallint and int since string overlap.
			if(hits.equals(Util.setify(ExchangeType.smallint, ExchangeType.m_int)))
				{ hits = Util.setify(ExchangeType.smallint); }

			Util.massert(hits.size() > 0, "No ExchangeType found for colname %s", scolname);
			Util.massert(hits.size() == 1, "Multiple exchange types found for colname %s :: %s", scolname, hits);
			
			return hits.iterator().next();
		}
		
		public boolean isJsInteger()
		{
			return this == ExchangeType.smallint || this == ExchangeType.m_int;
		}
		
		public boolean isJsFloat()
		{
			return this == ExchangeType.real || this == ExchangeType.m_double;
		}
	}
	
	public final Pair<WidgetItem, String> dbTabPair;

	// Note: the order of these keys are very important
	private LinkedHashMap<String, String> _colTypeMap = Util.linkedhashmap();
	
	private List<String> _pkeyList = Util.vector();

	private Boolean _isBlobStore = null;

	private final boolean _noDataMode;
	
	
	public LiteTableInfo(WidgetItem widget, String table)
	{
		this(widget, table, false);
	}


	public LiteTableInfo(WidgetItem widget, String table, boolean nodata)
	{
		dbTabPair = Pair.build(widget, table);
				
		Util.massert(table.length() > 0, "Empty table name");
		Util.massert(table.toLowerCase().equals(table),
			"Table names should be lower case");
		String basic = getBasicName();
		_noDataMode = nodata;
	}
	
	public LiteTableInfo(ArgMap onemap)
	{
		WidgetUser wowner = WidgetUser.valueOf(onemap.getStr("wowner"));
		String wname = onemap.getStr("wname");
		String table = onemap.getStr("tablename");
				
		dbTabPair = Pair.build(new WidgetItem(wowner, wname), table);
		
		// TODO: need to document the assumptions made regarding the table names
		// If we are really requiring all table names to be lowercase, we'd better check that on DB upload
		Util.massert(table.length() > 0, "Empty table name");
		Util.massert(table.toLowerCase().equals(table),
			"Table names should be lower case");
		
		// Util.pf("%s\n", dbTabPair);
		String basic = getBasicName();
		_noDataMode = false;
	}

	public void runSetupQuery()
	{
		try {
			Connection conn = dbTabPair._1.createConnection();
			
			String prepsql = Util.sprintf("SELECT * FROM %s LIMIT 1", dbTabPair._2);
			
			PreparedStatement pstmt = conn.prepareStatement(prepsql);
			
			ResultSet rset = pstmt.executeQuery();
			
			ResultSetMetaData rsmd = rset.getMetaData();
			
			popColTypeMap(rsmd);
			
			popKeyList(conn);
			
			conn.close();

			_isBlobStore = BlobDataManager.isBlobStorageTable(_colTypeMap.keySet());
			
		} catch (Exception ex) {
			
			throw new RuntimeException(ex);	
		}
	}
	
	
	
	public void printInfo()
	{
		Util.pf("Col2Type map: %s\n", _colTypeMap);
		
		Util.pf("PKey List: %s\n", _pkeyList);
	}
	
	private void popColTypeMap(ResultSetMetaData rsmd) throws SQLException
	{
		for(int ci : Util.range(rsmd.getColumnCount()))
		{
			String colname = rsmd.getColumnName(ci+1);
			
			String classname = rsmd.getColumnTypeName(ci+1);
			
			ExchangeType etype = ExchangeType.lookupFromSql(classname);
			
			_colTypeMap.put(colname, classname);
		}
	}
	
	ExchangeType getColumnExType(String colname)
	{
		String classname = _colTypeMap.get(colname);
		Util.massert(classname != null, 
			"Unknown column %s, options are %s", colname, _colTypeMap.keySet());
		
		return ExchangeType.lookupFromSql(classname);
	}
	
	private void popKeyList(Connection conn) throws SQLException
	{
		String pragsql = Util.sprintf("PRAGMA table_info(%s)", dbTabPair._2);
		
		PreparedStatement pstmt = conn.prepareStatement(pragsql);
		
		ResultSet rset = pstmt.executeQuery();
		
		while(rset.next())
		{
			String colname = rset.getString(2);
			
			int ispkey = rset.getInt(6);
			
			if(ispkey > 0)
				{ _pkeyList.add(colname); }
		}
		
		conn.close();
		
		Util.massert(!_pkeyList.isEmpty(), 
			"Found no Primary Key for table %s", dbTabPair._2);
	}
	
	public WidgetItem getWidget()
	{
		return dbTabPair._1;	
	}
	
	public String getWidgetOwner()
	{
		return dbTabPair._1.theOwner.toString();	
	}
	
	public String getWidgetName()
	{
		return dbTabPair._1.theName;	
	}
	
	public String getBasicName()
	{
		return CoreUtil.snake2CamelCase(dbTabPair._2);	
	}
	
	public String getSimpleTableName()
	{
		return dbTabPair._2;	
	}
	
	public String getRecordName()
	{
		return getBasicName() + "Item";	
	}
	
	// TODO: remove references to this in actual hand-written code,
	// then rename to something like __XyzTable;
	public String getCollectName()
	{
		return getBasicName() + "Table";
	}
	
	public List<String> getPkeyList()
	{
		return Collections.unmodifiableList(_pkeyList);	
	}
	
	public ConnectionSource getDbRef()
	{
		return dbTabPair._1;
	}
	
	public Map<String, String> getColTypeMap()
	{
		return Collections.unmodifiableMap(_colTypeMap);	
		
	}
	
	public String getCsvPkeyStr()
	{
		return Util.join(_pkeyList, ", ");	
	}
	
	// Okay, this method can't be offloaded to JS creator, it needs to run every time.
	public List<String> composeDataRecSpool()
	{
		return composeDataRecSpool(dbTabPair._2);
	}
	
	List<String> composeDataRecSpool(String querytarget)
	{
		Util.massert(!_colTypeMap.isEmpty(), 
			"You must call runQuery before creating the data, sorry bad naming");
		
		List<String> reclist = Util.vector();
				
		reclist.add("");
		reclist.add("");
		reclist.add("");
		
		reclist.addAll(composeJsonRepList(querytarget));

		return reclist;
	}
	
	private List<String> composeJsonRepList(String querytarget)
	{
		Util.massert(!_colTypeMap.isEmpty(), 
			"You must call runQuery before creating the data, sorry bad naming");
		
		
		List<ArgMap> recordList = Collections.emptyList();

		if(!_noDataMode) 
		{
			QueryCollector bigcol = QueryCollector.buildAndRun("SELECT * FROM " + querytarget, dbTabPair._1);

			recordList = bigcol.getArgMapList();
		}

		List<String> jsonitems = Util.vector();
		
		for(ArgMap onemap : recordList)
		{
			List<String> arglist = _colTypeMap.keySet()
							.stream()
							.map(onekey -> getArrayRep(onemap, onekey))
							.collect(CollUtil.toList());
			
			// reclist.add(Util.sprintf("%sTable.register(new %sItem(%s));", getBasicName(), getBasicName(), Util.join(arglist, ", ")));
			StringBuilder sb = new StringBuilder();
			sb.append("\t[ ");
			sb.append(Util.join(arglist, ", "));
			sb.append("] ");
			
			// String jsonitem = Util.sprintf("\t{ %s }", Util.join(arglist, ", "));
			jsonitems.add(sb.toString());
		}
		
		List<String> reclist = Util.vector();

		String converter = Util.sprintf("__arr2Dict%s", getBasicName());
		
		{
			List<String> cols = Util.vector(_colTypeMap.keySet());
			
			reclist.add(Util.sprintf("function %s(arr) {", converter));
			reclist.add("\tconst d = {};");
			
			int idx = 0;
			
			for(String col : _colTypeMap.keySet())
			{
				String assign = Util.sprintf("arr[%d]", idx);
				if(SQLITE_STR_TYPE.contains(_colTypeMap.get(col).toLowerCase()))
					{ assign = Util.sprintf("decodeURIComponent(%s)", assign); }
				
				reclist.add(Util.sprintf("\td['%s'] = %s;", col, assign));
				idx++;
			}
			
			reclist.add("\treturn d;");
			reclist.add("}");
		}
		
		
		reclist.add("[");
		for(int i : Util.range(jsonitems)) 
		{
			String jsitem = jsonitems.get(i);
			String maybecomma = i < jsonitems.size() - 1 ? " , " : "";
			reclist.add(jsitem + maybecomma);
		}
		reclist.add(Util.sprintf("].forEach(function(myrec) { \n\t%sTable.register(W.buildItem(\"%s\", %s(myrec)));\n});", 
			getBasicName(), dbTabPair._2, converter));

		
		reclist.add("");
		reclist.add("// " + LOAD_SUCCESS_TAG);
		
		return reclist;
	}
	
	private String getArrayRep(ArgMap onemap, String onecol)
	{
		String s = onemap.getStr(onecol);

		// Util.massert(s != null,
		//	"Found null value for column %s, this system cannot handle nulls, use empty strings", onecol);
		
		if(s == null)
			{ return null + ""; }

		// Need to put quotes around string types
		if(!SQLITE_STR_TYPE.contains(_colTypeMap.get(onecol).toLowerCase()))
			{ return s; }

		StringBuilder sb = new StringBuilder();
		sb.append("\"");
		sb.append(myEncodeURIComponent(s));
		sb.append("\"");
		return sb.toString();
	}


	// Return list of list of column names
	// Each index is a list of columns
	// Order matters!!
	public List<List<String>> getIndexInfo()
	{
		// This is all the indexes for the whole DB
		Map<String, String> indexmap = CoreDb.getLiteIndexMap(dbTabPair._1);

		// Filter down to the ones for this table
		return indexmap.entrySet()
						.stream()
						.filter(pr -> !pr.getKey().contains("sqlite_autoindex"))
						.filter(pr -> pr.getValue().equals(dbTabPair._2))
						.map(pr -> CoreDb.getIndexColumnList(dbTabPair._1, pr.getKey()))
						.collect(CollUtil.toList());
	}



	public Map<String, Object> getDefaultInfo()
	{
		var coldef = loadColumnDefinition(dbTabPair._1, dbTabPair._2);
		return getDefaultReadout(coldef);
	}


	
	void processAjaxOp(ArgMap argmap)
	{
		// TODO: this is going to probably cause some scalability issues
		// when we get to 100000's of tables
		SyncController editcontrol = getEditController(dbTabPair._1);
		
		synchronized(editcontrol)
		{
			String ajaxop = argmap.getStr("ajaxop");
			
			if(ajaxop.equals("upsert"))
			{
				doUpsert(argmap);
				return;
			}
			
			if(ajaxop.equals("delete"))
			{
				doDelete(argmap);
				return;
			}
			
			Util.massert(false, "Unknown AjaxOp %s", ajaxop);
		}
	}
	
	public boolean isBlobStoreTable()
	{
		Util.massert(_isBlobStore != null, "Must call runSetupQuery first");

		return _isBlobStore;
	}

	public void doUpsert(ArgMap argmap)
	{
		Util.massert(argmap.getStr("tablename").equals(dbTabPair._2),
			"Wrong table name: %s vs %s", argmap.getStr("tablename"), dbTabPair._2);
		
		LinkedHashMap<String, Object> paymap = getPayLoadMap(argmap, _colTypeMap.keySet());

		// If the payload has blob data, this operation swaps out the blob data and writes the file to disk and S3
		// What gets entered into the SQLite table is the blob coords, not the blob data itself
		BlobDataManager.optProcessBlobInput(this, paymap);
		
		CoreDb.upsertFromRecMap(dbTabPair._1, dbTabPair._2, _pkeyList.size(), paymap);
	}
	
	public void doDelete(ArgMap argmap)
	{
		Util.massert(argmap.getStr("tablename").equals(dbTabPair._2),
			"Wrong table name: %s vs %s", argmap.getStr("tablename"), dbTabPair._2);
		
		// TODO: historical versions of WWIO allowed multi-column primary keys
		// Current version (Oct 2023) allows only single-column primary key with Integer "id"
		// So this command really just getRecMap("id", argmap.getInt("id"))); 
		LinkedHashMap<String, Object> paymap = getPayLoadMap(argmap, _pkeyList);

		BlobDataManager.optProcessDelete(this, paymap);
		
		CoreDb.deleteFromColMap(dbTabPair._1, dbTabPair._2, paymap);
	}
	
	
	private LinkedHashMap<String, Object> getPayLoadMap(ArgMap argmap, Collection<String> arglist)
	{
		LinkedHashMap<String, Object> paymap = Util.linkedhashmap();
		
		for(String onecol : arglist)
		{
			String onetype = _colTypeMap.get(onecol);
			
			Object payload = getPayLoad(onecol, onetype, argmap);
			
			paymap.put(onecol, payload);
		}
		
		return paymap;
	}

	LinkedHashMap<String, Object> getPayLoadMap(JSONObject jsonob)
	{

		// Blah my map2map collection operation doesn't work here because it uses TreeMap
		// and doesn't let me control the backing map type


		LinkedHashMap<String, Object> paymap = Util.linkedhashmap();
		for(var coltype : _colTypeMap.entrySet())
		{
			Object payload = getJsonPayLoad(coltype.getKey(), coltype.getValue(), jsonob);
			paymap.put(coltype.getKey(), payload);
		}
		return paymap;
	}

	
	static Object getPayLoad(String onecol, String onetype, ArgMap recmap)
	{
		try 
		{
			switch(onetype)
			{
				case "INT": return recmap.getInt(onecol);
				case "INTEGER" : return recmap.getInt(onecol);
				case "TINYINT": return recmap.getInt(onecol);
				case "SMALLINT": return recmap.getInt(onecol);
				case "VARCHAR": return recmap.getStr(onecol);
				case "TEXT"   : return recmap.getStr(onecol);
				case "STRING": return recmap.getStr(onecol);
				case "REAL" : return recmap.getDbl(onecol);
				case "DOUBLE": return recmap.getDbl(onecol);
				default: throw new RuntimeException("Unknown Type: " + onetype);
			}
		} catch (NumberFormatException nfex) {

			String input = recmap.get(onecol);
			throw new ArgMapNumberException(onecol, onetype, input);
		}
	}


	static Object getJsonPayLoad(String onecol, String onetype, JSONObject jsonob)
	{
		java.util.function.Function<Object, Integer> convertlong = ob -> (ob == null ? null : ((Long) ob).intValue());
		java.util.function.Function<Object, Double> convertreal = ob -> (ob == null ? null : ((Number) ob).doubleValue());


		switch(onetype)
		{
			case "INT":
			case "TINYINT":
			case "SMALLINT":
			case "INTEGER" : return convertlong.apply(jsonob.get(onecol));


			case "REAL":
			case "DOUBLE": return convertreal.apply(jsonob.get(onecol));

			case "VARCHAR":
			case "TEXT": 
			case "STRING": return (String) jsonob.get(onecol);

			default: throw new RuntimeException("Unknown Type: " + onetype);
		}
	}

	// Load the SQLite create table statement, parse in the column name :: definition pairs
	// This code is replicated in DataDesigner in extension package
	// Eventually need a complete class that represents everything about a SQLite table definition
	// TODO: this code will break if the user uploads a table with an INDEX or UNIQUE definition in it
    public static LinkedHashMap<String, String> loadColumnDefinition(WidgetItem item, String table)
    {
        String tablesql = CoreUtil.getCreateTableSql(item, table).strip().replaceAll("\n", " ");

        Matcher basicmatch = BASIC_TABLE_MATCH.matcher(tablesql);
        if(!basicmatch.find())
        {
            throw new RuntimeException("Bad table definition : " + tablesql);
        }

        {
            String sanity = basicmatch.group(1);

            if(!sanity.toLowerCase().equals(table.toLowerCase()))
            {
                String errmssg = String.format("Requested table name %s, but CREATE TABLE returned %s!!!", table, sanity);
                throw new RuntimeException(errmssg);
            }
        }

        var result = new LinkedHashMap<String, String>();

        String columnDef = basicmatch.group(2);

        var colDefList = Util.linkedlistify(columnDef.split(","));

        checkPollPrimaryKey(colDefList);

        for(String colpair : colDefList)
		{
			String trimmed = colpair.trim();
	        int spaceidx = trimmed.indexOf(" ");
	        String colname = trimmed.substring(0, spaceidx);
	        String coldef = trimmed.substring(spaceidx+1);
	        result.put(colname, coldef);
		}

        String firstcol = result.keySet().iterator().next().toLowerCase();
        Util.massert(firstcol.equals("id"), "Expected 'id' as first column, but found %s", firstcol);

        return result;
    }

    private static String basicStringReduce(String mystr)
    {
        return mystr.toLowerCase().replaceAll(" ", "");
    }

    private static void checkPollPrimaryKey(LinkedList<String> colinfo)
    {
    	boolean foundprim = false;

    	while(!colinfo.isEmpty())
    	{
    		String reduced = basicStringReduce(colinfo.peekLast());

			String fkred = basicStringReduce("foreign key");
			if(reduced.contains(fkred))
			{
				colinfo.pollLast();
				continue;
			}

			String primkey = basicStringReduce("primary key(id)");
			if(reduced.equals(primkey))
			{
				colinfo.pollLast();
				foundprim = true;
				continue;
			}

			break;
    	}

    	Util.massert(foundprim, "Failed to find primary key, columns are %s", colinfo);
    }

    public static Map<String, Object> getDefaultReadout(LinkedHashMap<String, String> coldef)
    {
    	var hitkeys = Util.filter2list(coldef.keySet(), k -> extractDefaultInfo(coldef.get(k)).isPresent());

    	return Util.map2map(hitkeys, k -> k, k -> extractDefaultInfo(coldef.get(k)).get());
    }

    public static Optional<Object> extractDefaultInfo(String defstart)
    {
    	String definition = defstart.replaceAll("\"", "'");

        Matcher matcher = DEFAULT_PATTERN.matcher(definition);

        if (matcher.find()) {

        	if(matcher.group(1) != null)
	        	{ return Optional.of(matcher.group(1)); }

	        if(matcher.group(2) != null)
	        { 
	        	String dstr = matcher.group(2);

	        	// Lots of PAIN here, trying to get it to return the right Integer/Double as appropriate
	        	// int dotidx = dstr.indexOf(".");

	        	// This is very very weird, but this statement doesn't work the way I want,
	        	// somehow the compiler decides to return Double in both cases. 
	        	// But spelling it out DOES work
	        	// Object o = (dotidx == -1 ? Integer.valueOf(dstr) : Double.valueOf(dstr));
	        	Object o;

	        	if(dstr.indexOf(".") == -1)
		        	{ o = Integer.valueOf(dstr); }
		        else
			        { o = Double.valueOf(dstr); }

	        	return Optional.of(o);
	        }

	        if(matcher.group(3) != null)
		    {
		    	String boolstr = matcher.group(3).toLowerCase();
		    	if(Util.setify(true+"", false+"").contains(boolstr))
		    		{ return Optional.of(Boolean.valueOf(boolstr)); }
		    }
        }

        return Optional.empty();

    }


	static Class getJavaTypeFromLite(String litetype)
	{
        ArgMap mymap = new ArgMap();
        mymap.put("dummy", "454534");

        Object lookup = LiteTableInfo.getPayLoad("dummy", litetype, mymap);
        return lookup.getClass();
	}

	public String getWebAutoGenJsPath()
	{
		Optional<File> jsfile = findAutoGenFile();
		Util.massert(jsfile.isPresent(),
			"AytoGen JS file must be present at this point!!");
		
		String pref = "/u/" + dbTabPair._1.theOwner.toString();
		
		return Util.sprintf("%s/autogenjs/%s/%s", pref, dbTabPair._1.theName, jsfile.get().getName());
	}
	
	List<String> maybeUpdateJsCode(boolean dogenerate)
	{
		Optional<File> prevfile = findAutoGenFile();
		// Normal situation - file exists and we aren't asked to generate it.
		if(prevfile.isPresent() && !dogenerate)
			{ return Util.listify(); }
		
		
		CodeGenerator ncgen = new CodeGenerator(this);
		List<String> newsrc = ncgen.getCodeLineList();
		
		if(oldVersionOkay(prevfile, newsrc))
		{
			String mssg = Util.sprintf("New version of AutoGen code identical to previous for DB %s\n", dbTabPair._2);
			return Util.listify(mssg);
		}
		
		int oldversion = prevfile.isPresent() ? this.getVersionFromPath(prevfile.get()) : 0;
		String newjspath = this.getAutoGenProbePath(oldversion+1);					
		
		FileUtils.getWriterUtil()
				.setFile(newjspath)
				.writeLineListE(newsrc);
		
		List<String> loglist = Util.vector();
		loglist.add(Util.sprintf("Wrote autogen code to path %s\n", newjspath));
		
		if(prevfile.isPresent())
		{
			prevfile.get().delete();
			loglist.add(Util.sprintf("Deleted old file %s\n", prevfile.get()));	
		}
		
		return loglist;		
	}

	
	// TODO: this does not go here
	static boolean oldVersionOkay(Optional<File> prevfile, List<String> newsrc)
	{
		if(!prevfile.isPresent())
			{ return false; }
		
		List<String> oldsrc = FileUtils.getReaderUtil()
							.setFile(prevfile.get())
							.setTrim(false)
							.readLineListE();

		return oldsrc.equals(newsrc);
	}
		
	String getAutoGenProbePath(int version)
	{
		File wdir = WebUtil.getAutoGenJsDir(dbTabPair._1);
		return Util.sprintf("%s/%s__%03d.js", wdir.toString(), getBasicName(), version);
	}
	
	// TODO: need to get rid of this hacky way of upgrading the versions
	// Just put the file modtime in there, Jesus
	int getVersionFromPath(File thefile)
	{	
		String fname = thefile.getName();
		String[] toks = fname.split("__");
		String justnum = CoreUtil.peelSuffix(toks[1], ".js");
		return Integer.valueOf(justnum);
	}

	private boolean matchesFileName(File thefile)
	{
		String fname = thefile.getName();
		String[] toks = fname.split("__");
		return getBasicName().equals(toks[0]);
	}	
	
	public Optional<File> findAutoGenFile()
	{
		File wdir = WebUtil.getAutoGenJsDir(dbTabPair._1);
		Util.massert(wdir.exists() && wdir.isDirectory(),
			"AutoGen JS Directory does not exist or is not directory %s", wdir);
		
		List<File> hits = Util.filter2list(wdir.listFiles(), f -> matchesFileName(f));
		Util.massert(hits.size() <= 1, "Found multiple versions of AutoGen JS file : %s", hits);
		
		return hits.isEmpty() ? Optional.empty() : Optional.of(hits.get(0));
	}



	private static Map<String, SyncController> __SYNC_MAP = Util.treemap();
	
	static synchronized SyncController getEditController(WidgetItem witem) 
	{
		String pathkey = witem.getLocalDbPath();
		
		__SYNC_MAP.putIfAbsent(pathkey, new SyncController());

		return __SYNC_MAP.get(pathkey);
	}
	
	static class SyncController {}
	
	
	// http://stackoverflow.com/questions/607176/java-equivalent-to-javascripts-encodeuricomponent-that-produces-identical-outpu		
	// NB: this method may have performance implications when used excessively.
	private static String myEncodeURIComponent(String s)
	{
		try
		{
			// Okay, Java's URL Encoder is different from the JS encodeURIComponent
			// in that a couple of things aren't escaped: !
			
			String encoded = java.net.URLEncoder.encode(s, "UTF-8");
			/*
			result = encoded
							.replaceAll("\\+", "%20")
							.replaceAll("\\%21", "!")
							.replaceAll("\\%27", "'")
							.replaceAll("\\%28", "(")
							.replaceAll("\\%29", ")")
							.replaceAll("\\%7E", "~");
							
			result = java.net.URLEncoder.encode(s, "UTF-8")
							.replace("+", "%20")
							.replace("%21", "!")
							.replace("%27", "'")
							.replace("%28", "(")
							.replace("%29", ")")
							.replace("%7E", "~");	
							
			*/
			
			return fastReplace(encoded);
						
			// String other = CoreUtil.encodeURIComponent(s);
			
			// Util.massert(result.equals(other),
			//	"Got result/other: \n\t%s\n\t%s", result, other);
		}
		
		// This exception should never occur.
		catch (UnsupportedEncodingException e)
		{
			throw new RuntimeException(e);
		}
	} 	
	
	private static Map<String, Character> _REPLACE_MAP = Util.treemap();
	
	static {
		_REPLACE_MAP.put("21", '!');
		_REPLACE_MAP.put("27", '\'');
		_REPLACE_MAP.put("28", '(');
		_REPLACE_MAP.put("29", ')');
		_REPLACE_MAP.put("7E", '~');
	}
	
	private static String fastReplace(String s)
	{
		StringBuilder sb = new StringBuilder();
		
		for(int i = 0; i < s.length(); i++)
		{
			char c = s.charAt(i);
			
			if(c == '+')
			{
				sb.append("%20");
				continue;
			}
			
			
			if(c == '%' && i < s.length()-2)
			{
				String probe = s.substring(i+1,i+3);
				if(_REPLACE_MAP.containsKey(probe))
				{
					sb.append(_REPLACE_MAP.get(probe));	
					i += 2;
					continue;
				}
			}
			
			
			sb.append(c);
		}
		
		return sb.toString();
	}

	static class ArgMapNumberException extends RuntimeException
	{

		ArgMapNumberException(String colname, String coltype, String inputstr)
		{
			super(getMessage(colname, coltype, inputstr));
		}

		private static String getMessage(String colname, String coltype, String inputstr)
		{
			return String.format("The input string %s could not be converted into a %s, for column %s", inputstr, coltype, colname);
		}

	}
}
