package io.webwidgets.core; 

import java.io.*; 
import java.util.*; 
import java.sql.*; 

import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.function.Consumer;

import javax.servlet.http.HttpServletRequest;
import org.json.simple.JSONObject;


import net.danburfoot.shared.Util;
import net.danburfoot.shared.CoreDb;
import net.danburfoot.shared.ArgMap;
import net.danburfoot.shared.CollUtil;
import net.danburfoot.shared.FileUtils;

import net.danburfoot.shared.CollUtil.*;
import net.danburfoot.shared.CoreDb.QueryCollector;
import net.danburfoot.shared.CoreDb.ConnectionSource;


import io.webwidgets.core.CoreUtil.*;

/**
 * Metadata about an underlying SQLite table
 * This class is used by the JS Code Generator to create the wrapper code that gets sent to the browser
 * This information is primarily generated by doing a SELECT * LIMIT 1 on the table and then examining
 * the ResultSetMetaData
 */
public class LiteTableInfo
{

    public static final Pattern BASIC_TABLE_MATCH = Pattern.compile("CREATE TABLE \"?(\\w+)\"?\\s*\\((.*?)\\)$");

    public static final Pattern DEFAULT_PATTERN = Pattern.compile("DEFAULT\\s+(?:(?:'([^']*)')|(\\d+(?:\\.\\d+)?)(?=\\s|,|$)|(\\w+))", Pattern.CASE_INSENSITIVE);

	public static final String LOAD_SUCCESS_TAG = LiteTableInfo.class.getSimpleName() + "__LOAD_SUCCESS";
	
	public enum ExchangeType
	{
		smallint,
		m_int("int"),
		real,
		m_double("double"),
		text,
		varchar;
		
		final String lookupTag;
		
		ExchangeType(String s)
		{
			lookupTag = s == null ? this.toString() : s;
		}
		
		ExchangeType()
		{
			this(null);
		}
	
		public static ExchangeType lookupFromSql(String scolname)
		{
			Set<ExchangeType> hits = Util.filter2set(ExchangeType.values(), et -> scolname.toLowerCase().contains(et.lookupTag));
			
			// Will hit both smallint and int since string overlap.
			if(hits.equals(Util.setify(ExchangeType.smallint, ExchangeType.m_int)))
				{ hits = Util.setify(ExchangeType.smallint); }

			Util.massert(hits.size() > 0, "No ExchangeType found for colname %s", scolname);
			Util.massert(hits.size() == 1, "Multiple exchange types found for colname %s :: %s", scolname, hits);
			
			return hits.iterator().next();
		}
		
		public boolean isJsInteger()
		{
			return this == ExchangeType.smallint || this == ExchangeType.m_int;
		}
		
		public boolean isJsFloat()
		{
			return this == ExchangeType.real || this == ExchangeType.m_double;
		}

		public boolean isJsString()
		{
			return this == ExchangeType.text || this == ExchangeType.varchar;
		}

		public String getJsType()
		{
			return isJsString() ? "string" : "number";
		}

		public Class getJavaType()
		{
			return isJsFloat() ? Double.class : (isJsInteger() ? Integer.class : String.class);
		}

		Object convertFromJson(JSONObject jsonob, String colname)
		{
			if(isJsInteger())
			{
				var ob = jsonob.get(colname);
				return ob == null ? null : ((Long) ob).intValue();
			}

			if(isJsFloat())
			{
				var ob = jsonob.get(colname);
				return ob == null ? null : ((Number) ob).doubleValue();

			}

			var ob = jsonob.get(colname);
			Util.massert(ob instanceof String, "Expected String for column %s but got %s", colname, ob);
			return ob;
		}

		Object convertFromArgMap(ArgMap recmap, String colname)
		{
			if(isJsInteger())
				{ return recmap.getInt(colname); }

			if(isJsFloat())
				{ return recmap.getDbl(colname); }

			return recmap.getStr(colname);
		}
	}
	
	public final Pair<WidgetItem, String> dbTabPair;

	// Note: the order of these keys are very important
	// Nov 2024: this is the new format for the _colTypeMap, we can get the ExchangeTypes from JDBC metadata
	private LinkedHashMap<String, ExchangeType> _exTypeMap = Util.linkedhashmap();

	private Pair<String, Object> _colFilterTarget = null;

	private Boolean _isBlobStore = null;

	// Set of groups that the accessing user is a member of,
	// in this DB's account space
	private Set<String> _checkAccessorGroupSet = null;

	private boolean _noDataMode;

	public LiteTableInfo(WidgetItem widget, String table)
	{
		dbTabPair = Pair.build(widget, table);
				
		Util.massert(table.length() > 0, "Empty table name");
		Util.massert(table.toLowerCase().equals(table), "Table names should be lower case");

		String basic = getBasicName();
		_noDataMode = false;
	}
	

	public static LiteTableInfo fromArgMap(ArgMap onemap)
	{
		WidgetUser owner = WidgetUser.valueOf(onemap.getStr("wowner"));
		String wname = onemap.getStr("wname");
		String table = onemap.getStr("tablename");
		return new LiteTableInfo(new WidgetItem(owner, wname), table);
	}

	public void runSetupQuery()
	{
		try {
			Connection conn = dbTabPair._1.createConnection();
			
			String prepsql = Util.sprintf("SELECT * FROM %s LIMIT 1", dbTabPair._2);
			
			PreparedStatement pstmt = conn.prepareStatement(prepsql);
			
			ResultSet rset = pstmt.executeQuery();
			
			ResultSetMetaData rsmd = rset.getMetaData();
			
			popColTypeMap(rsmd);
						
			conn.close();

			_isBlobStore = BlobDataManager.isBlobStorageTable(_exTypeMap.keySet());
			
		} catch (Exception ex) {
			
			throw new RuntimeException(ex);
		}
	}

	private void odRunSetup()
	{
		if(_exTypeMap.isEmpty())
			{ runSetupQuery(); }

		Util.massert(!_exTypeMap.isEmpty(), "Table %s apparently has no columns", dbTabPair);
	}
	
	
	public LiteTableInfo withNoDataMode(boolean ndmode)
	{
		_noDataMode = ndmode;
		return this;
	}

	public LiteTableInfo withColumnTarget(String colname, Object value)
	{
		Util.massert(_exTypeMap != null, "You must run the setup query first");
		Util.massert(_exTypeMap.containsKey(colname), 
			"Attempt to filter on missing column %s, options are %s", colname, _exTypeMap.keySet());

		_colFilterTarget = Pair.build(colname, value);
		return this;
	}

	public LiteTableInfo withAccessorGroupSet(Set<String> groupset)
	{
		Util.massert(hasGranularPerm(), "Attempt to check group set, but this LTI is not configured for granular permissions");
		_checkAccessorGroupSet = groupset;
		return this;
	}
	
	private void popColTypeMap(ResultSetMetaData rsmd) throws SQLException
	{
		for(int ci : Util.range(rsmd.getColumnCount()))
		{
			String colname = rsmd.getColumnName(ci+1);
			
			String classname = rsmd.getColumnTypeName(ci+1);
			
			ExchangeType etype = ExchangeType.lookupFromSql(classname);

			_exTypeMap.put(colname, etype);
		}

		// TODO: reintroduce this assertion, my old DB tables are not configured properly
		boolean isdcb = dbTabPair._1.theOwner.toString().equals("dburfoot");
		Util.massert(isdcb || _exTypeMap.keySet().iterator().next().toLowerCase().equals(CoreUtil.STANDARD_ID_COLUMN_NAME),
				"Expect first column to be ID, but got %s, for %s", _exTypeMap.keySet(), dbTabPair);
	}
	
	public WidgetItem getWidget()
	{
		return dbTabPair._1;
	}
	
	public String getWidgetOwner()
	{
		return dbTabPair._1.theOwner.toString();
	}
	
	public String getWidgetName()
	{
		return dbTabPair._1.theName;
	}
	
	public String getBasicName()
	{
		return CoreUtil.snake2CamelCase(dbTabPair._2);
	}
	
	public String getSimpleTableName()
	{
		return dbTabPair._2;
	}
	
	public String getRecordName()
	{
		return getBasicName() + "Item";
	}
	
	public ConnectionSource getDbRef()
	{
		return dbTabPair._1;
	}
	
	public Set<String> getColumnNameSet()
	{
		odRunSetup();
		return Collections.unmodifiableSet(_exTypeMap.keySet());

	}
	
	public Map<String, ExchangeType> getColumnExTypeMap()
	{
		odRunSetup();
		return Collections.unmodifiableMap(_exTypeMap);
	}


	// Okay, this method can't be offloaded to JS creator, it needs to run every time.
	public List<String> composeDataRecSpool()
	{
		return composeDataRecSpool(dbTabPair._2);
	}
	
	List<String> composeDataRecSpool(String querytarget)
	{
		Util.massert(!_exTypeMap.isEmpty(),
			"You must call runQuery before creating the data, sorry bad naming");
		
		List<String> reclist = Util.vector();
				
		reclist.add("");
		reclist.add("");
		reclist.add("");
		
		reclist.addAll(composeJsonRepList(querytarget));

		return reclist;
	}
	

	// TODO: all of the query-specific logic should be in another place, and another class
	// The LiteTableInfo is metadata about a TABLE, not a QUERY
	public List<ArgMap> loadRecordList(String querytarget)
	{
		Util.massert(!_exTypeMap.isEmpty(),
			"You must call runQuery before creating the data, sorry bad naming");
		
		Util.massert(_checkAccessorGroupSet == null || hasGranularPerm(),
			"Attempt to check granular permissions, but this table is not configured for granular perms");
		
		if(_noDataMode)
			{ return Collections.emptyList(); }

		String query = "SELECT * FROM " + querytarget;
		QueryCollector bigcol;

		Util.massert(_colFilterTarget == null || _checkAccessorGroupSet == null,
			"As of Jan 2025, cannot use filter column targets with auth owner targets");

		if(_colFilterTarget != null)
		{
			query += String.format(" WHERE %s = ? ", _colFilterTarget._1);
			bigcol = QueryCollector.buildRunPrepared(query, dbTabPair._1, _colFilterTarget._2);

		} else if (_checkAccessorGroupSet != null) {

			// Note: the querytarget is usually, but not ALWAYS, the same as the table name - sometimes
			// it's a view that is built from the underlying table
			String auxtable = GranularPerm.getAuxGroupTable(dbTabPair._2);
			query += String.format(
				" WHERE id IN (SELECT record_id FROM %s WHERE group_name IN (%s) )",
				auxtable, CoreDb.nQuestionMarkStr(_checkAccessorGroupSet.size())
			);

			// query += String.format(" WHERE %s IN (%s) ", CoreUtil.AUTH_OWNER_COLUMN, CoreDb.nQuestionMarkStr(_checkAccessorGroupSet.size()));
			bigcol = QueryCollector.buildRunPrepared(query, dbTabPair._1, _checkAccessorGroupSet.toArray());

		} else {
			bigcol = QueryCollector.buildAndRun(query, dbTabPair._1);
		}

		return bigcol.getArgMapList();
	}

	private List<String> composeJsonRepList(String querytarget)
	{
		
		List<ArgMap> recordList = loadRecordList(querytarget);

		List<String> jsonitems = Util.vector();
		
		for(ArgMap onemap : recordList)
		{
			List<String> arglist = _exTypeMap.keySet()
							.stream()
							.map(onekey -> getArrayRep(onemap, onekey))
							.collect(CollUtil.toList());
			
			// reclist.add(Util.sprintf("%sTable.register(new %sItem(%s));", getBasicName(), getBasicName(), Util.join(arglist, ", ")));
			StringBuilder sb = new StringBuilder();
			sb.append("\t[ ");
			sb.append(Util.join(arglist, ", "));
			sb.append("] ");
			
			// String jsonitem = Util.sprintf("\t{ %s }", Util.join(arglist, ", "));
			jsonitems.add(sb.toString());
		}
		
		List<String> reclist = Util.vector();

		String converter = Util.sprintf("__arr2Dict%s", getBasicName());
		
		{
			List<String> cols = Util.vector(_exTypeMap.keySet());
			
			reclist.add(Util.sprintf("function %s(arr) {", converter));
			reclist.add("\tconst d = {};");
			
			int idx = 0;
			
			for(var colexpair : _exTypeMap.entrySet())
			{
				String assign = Util.sprintf("arr[%d]", idx);
				if(colexpair.getValue().isJsString())
					{ assign = Util.sprintf("decodeURIComponent(%s)", assign); }
				
				reclist.add(Util.sprintf("\td['%s'] = %s;", colexpair.getKey(), assign));
				idx++;
			}
			
			reclist.add("\treturn d;");
			reclist.add("}");
		}
		
		
		reclist.add("[");
		for(int i : Util.range(jsonitems)) 
		{
			String jsitem = jsonitems.get(i);
			String maybecomma = i < jsonitems.size() - 1 ? " , " : "";
			reclist.add(jsitem + maybecomma);
		}

		// This is the primary connection between the code generation and the code library
		// The tableNameIndex returns the table object, which has a register(...) function
		reclist.add(Util.sprintf("].forEach(function(myrec) { \n\tW.__tableNameIndex.get('%s').register(W.buildItem('%s', %s(myrec)));\n});", 
			dbTabPair._2, dbTabPair._2, converter));

		
		reclist.add("");
		reclist.add("// " + LOAD_SUCCESS_TAG);
		
		return reclist;
	}
	
	// Return the JSON-valid representation of the value in the given column
	// This could be the literal null, a literal numeric representation, or a quoted string
	private String getArrayRep(ArgMap onemap, String onecol)
	{
		String s = onemap.getStr(onecol);

		// Util.massert(s != null,
		//	"Found null value for column %s, this system cannot handle nulls, use empty strings", onecol);
		
		if(s == null)
			{ return null + ""; }

		// Need to put quotes around string types
		if(!_exTypeMap.get(onecol).isJsString())
			{ return s; }

		StringBuilder sb = new StringBuilder();
		sb.append("\"");

		// May 2024 note: could not detect any performance improvements by using the library version of the escape operation
		// sb.append(_useJsonQuote ? org.json.simple.JSONValue.escape(s) : myEncodeURIComponent(s));

		sb.append(CoreUtil.myEncodeURIComponent(s));
		sb.append("\"");
		return sb.toString();
	}

	public Map<String, Object> getDefaultInfo()
	{
		var coldef = loadColumnDefinition(dbTabPair._1, dbTabPair._2);
		return getDefaultReadout(coldef);
	}


	// True if the table has "granular" permissions
	public boolean hasGranularPerm()
	{
		Util.massert(_exTypeMap != null && !_exTypeMap.isEmpty(), "You must run the setup query first");
		return _exTypeMap.containsKey(CoreUtil.GROUP_ALLOW_COLUMN);
	}

	Optional<ArgMap> lookupRecordById(int recordid)
	{
		String where = String.format(" %s = %d ", CoreUtil.STANDARD_ID_COLUMN_NAME, recordid);

		// This is fast; all WWIO tables have single PKey
		QueryCollector query = CoreUtil.tableQuery(dbTabPair._1, dbTabPair._2, Util.listify(where));

		return query.getNumRec() > 0 ? Optional.of(query.getSingleArgMap()) : Optional.empty();
	}

	static boolean isUpsertAjaxOp(ArgMap argmap)
	{
		String ajaxop = argmap.getStr("ajaxop");
		boolean isups = ajaxop.equals("upsert");
		boolean isdel = ajaxop.equals("delete");

		Util.massert(isups || isdel, "Bad Ajax Operation code %s", ajaxop);
		return isups;
	}

	
	void processAjaxOp(ArgMap argmap)
	{
		// Modestly better performance to do this here, rather than within sync block
		Consumer<ArgMap> myfunc = isUpsertAjaxOp(argmap) ? this::doUpsert : this::doDelete;

		SyncController editcontrol = getEditController(dbTabPair._1);
		
		synchronized(editcontrol)
		{
			myfunc.accept(argmap);
		}
	}
	
	public boolean isBlobStoreTable()
	{
		Util.massert(_isBlobStore != null, "Must call runSetupQuery first");

		return _isBlobStore;
	}

	private void doUpsert(ArgMap argmap)
	{
		Util.massert(argmap.getStr("tablename").equals(dbTabPair._2),
			"Wrong table name: %s vs %s", argmap.getStr("tablename"), dbTabPair._2);
		
		LinkedHashMap<String, Object> paymap = getPayLoadMap(argmap);

		// If the payload has blob data, this operation swaps out the blob data and writes the file to disk and S3
		// What gets entered into the SQLite table is the blob coords, not the blob data itself
		BlobDataManager.optProcessBlobInput(this, paymap);
		
		// All WWIO tables have 1 primary key
		CoreDb.upsertFromRecMap(dbTabPair._1, dbTabPair._2, 1, paymap);

		// TODO: 
		boolean granupdate = GranularPerm.testModeTransferGroupAllow(dbTabPair._1, dbTabPair._2, argmap);
		if(granupdate)
		{
			Util.pf("Ran Group Allow transfer for %s::%s\n", dbTabPair._1, dbTabPair._2);
		}
	}
	
	private void doDelete(ArgMap argmap)
	{
		Util.massert(argmap.getStr("tablename").equals(dbTabPair._2),
			"Wrong table name: %s vs %s", argmap.getStr("tablename"), dbTabPair._2);
		
		// Single record of "id" -> integer ID
		LinkedHashMap<String, Object> paymap = CoreDb.getRecMap(
			CoreUtil.STANDARD_ID_COLUMN_NAME, argmap.getInt(CoreUtil.STANDARD_ID_COLUMN_NAME)
		);

		BlobDataManager.optProcessDelete(this, paymap);
		
		CoreDb.deleteFromColMap(dbTabPair._1, dbTabPair._2, paymap);
	}
	
	
	// Convert the ArgMap representation of a record payload to the LHM version
	// Follow ordering of given collection
	// Use the appropriate getXYZ methods on ArgMap to convert
	private LinkedHashMap<String, Object> getPayLoadMap(ArgMap argmap)
	{
		return convertPayLoadSub(argmap, null);
	}

	// Convert a list of JSONObjects, from JSON.parse(...), into LHM form for insert
	List<LinkedHashMap<String, Object>> bulkConvert(List<?> jsonlist)
	{
        Util.massert(!_exTypeMap.isEmpty(), "You must setup the LiteTable before calling!!");
        return Util.map2list(jsonlist, ob -> convertPayLoadSub(null, ((JSONObject) ob)));
	}

	// Convert from either ArgMap or JSON to LHM
	// 
	private LinkedHashMap<String, Object> convertPayLoadSub(ArgMap argmap, JSONObject jsonob)
	{
		LinkedHashMap<String, Object> paymap = Util.linkedhashmap();
		
		for(var colname : _exTypeMap.keySet())
		{
			var ob = argmap != null ? exchangeConvert(argmap, colname) : exchangeConvert(jsonob, colname);
			paymap.put(colname, ob);
		}

		return paymap;
	}

	private Object exchangeConvert(ArgMap recmap, String onecol)
	{
		String probe = recmap.get(onecol);
		if(CoreUtil.MAGIC_NULL_STRING.equals(probe))
			{ return null; }

		ExchangeType coltype = getExchangeType(onecol);

		try {
			return coltype.convertFromArgMap(recmap, onecol);
		} catch (NumberFormatException nfex) {

			String input = recmap.get(onecol);
			throw new ArgMapNumberException(onecol, coltype, input);
		}
	}

	private Object exchangeConvert(JSONObject jsonob, String onecol)
	{
		Object probe = jsonob.get(onecol);
		if(CoreUtil.MAGIC_NULL_STRING.equals(probe))
			{ return null; }

		ExchangeType coltype = getExchangeType(onecol);
		return coltype.convertFromJson(jsonob, onecol);
	}


	public ExchangeType getExchangeType(String colname)
	{
		var litedef = _exTypeMap.get(colname);
		Util.massert(litedef != null, "Attempt to lookup Exchange Type for non-existent column %s", colname);
		return litedef;
	}


	// Load the SQLite create table statement, parse in the column name :: definition pairs
	// This code is replicated in DataDesigner in extension package
	// Eventually need a complete class that represents everything about a SQLite table definition
	// TODO: this code will break if the user uploads a table with an INDEX or UNIQUE definition in it
	// This section needs a lot of work, this is probably not the right way to discover default data
    public static LinkedHashMap<String, String> loadColumnDefinition(WidgetItem item, String table)
    {
        String tablesql = CoreUtil.getCreateTableSql(item, table).strip().replaceAll("\n", " ");

        Matcher basicmatch = BASIC_TABLE_MATCH.matcher(tablesql);
        if(!basicmatch.find())
        {
            throw new RuntimeException("Bad table definition : " + tablesql);
        }

        {
            String sanity = basicmatch.group(1);

            if(!sanity.toLowerCase().equals(table.toLowerCase()))
            {
                String errmssg = String.format("Requested table name %s, but CREATE TABLE returned %s!!!", table, sanity);
                throw new RuntimeException(errmssg);
            }
        }

        var result = new LinkedHashMap<String, String>();

        String columnDef = basicmatch.group(2);

        var colDefList = Util.linkedlistify(columnDef.split(","));

        checkPollPrimaryKey(colDefList);

        for(String colpair : colDefList)
		{
			String trimmed = colpair.trim();
	        int spaceidx = trimmed.indexOf(" ");
	        String colname = trimmed.substring(0, spaceidx);
	        String coldef = trimmed.substring(spaceidx+1);
	        result.put(colname, coldef);
		}

        String firstcol = result.keySet().iterator().next().toLowerCase();
        Util.massert(firstcol.equals("id"), "Expected 'id' as first column, but found %s", firstcol);

        return result;
    }

	private static String getCreateTableSql(ConnectionSource witem, String tablename)
	{
		String query = Util.sprintf("SELECT sql FROM sqlite_master WHERE type = 'table' AND tbl_name = '%s'", tablename);
		QueryCollector qcol = QueryCollector.buildAndRun(query, witem);
		return qcol.getSingleArgMap().getSingleStr();
	}



    private static String basicStringReduce(String mystr)
    {
        return mystr.toLowerCase().replaceAll(" ", "");
    }

    private static void checkPollPrimaryKey(LinkedList<String> colinfo)
    {
    	boolean foundprim = false;

    	while(!colinfo.isEmpty())
    	{
    		String reduced = basicStringReduce(colinfo.peekLast());

			String fkred = basicStringReduce("foreign key");
			if(reduced.contains(fkred))
			{
				colinfo.pollLast();
				continue;
			}

			String primkey = basicStringReduce("primary key(id)");
			if(reduced.equals(primkey))
			{
				colinfo.pollLast();
				foundprim = true;
				continue;
			}

			break;
    	}

    	Util.massert(foundprim, "Failed to find primary key, columns are %s", colinfo);
    }

    public static Map<String, Object> getDefaultReadout(LinkedHashMap<String, String> coldef)
    {
    	var hitkeys = Util.filter2list(coldef.keySet(), k -> extractDefaultInfo(coldef.get(k)).isPresent());

    	return Util.map2map(hitkeys, k -> k, k -> extractDefaultInfo(coldef.get(k)).get());
    }

    public static Optional<Object> extractDefaultInfo(String defstart)
    {
    	String definition = defstart.replaceAll("\"", "'");

        Matcher matcher = DEFAULT_PATTERN.matcher(definition);

        if (matcher.find()) {

        	if(matcher.group(1) != null)
	        	{ return Optional.of(matcher.group(1)); }

	        if(matcher.group(2) != null)
	        { 
	        	String dstr = matcher.group(2);

	        	// Lots of PAIN here, trying to get it to return the right Integer/Double as appropriate
	        	// int dotidx = dstr.indexOf(".");

	        	// This is very very weird, but this statement doesn't work the way I want,
	        	// somehow the compiler decides to return Double in both cases. 
	        	// But spelling it out DOES work
	        	// Object o = (dotidx == -1 ? Integer.valueOf(dstr) : Double.valueOf(dstr));
	        	Object o;

	        	if(dstr.indexOf(".") == -1)
		        	{ o = Integer.valueOf(dstr); }
		        else
			        { o = Double.valueOf(dstr); }

	        	return Optional.of(o);
	        }

	        if(matcher.group(3) != null)
		    {
		    	String boolstr = matcher.group(3).toLowerCase();
		    	if(Util.setify(true+"", false+"").contains(boolstr))
		    		{ return Optional.of(Boolean.valueOf(boolstr)); }
		    }
        }

        return Optional.empty();
    }

	public String getWebAutoGenJsPath()
	{
		Optional<File> jsfile = findAutoGenFile();
		Util.massert(jsfile.isPresent(),
			"AytoGen JS file must be present at this point!!");
		
		String pref = "/u/" + dbTabPair._1.theOwner.toString();
		
		return Util.sprintf("%s/autogenjs/%s/%s", pref, dbTabPair._1.theName, jsfile.get().getName());
	}
	
	public Optional<File> findAutoGenFile()
	{
		File wdir = dbTabPair._1.getAutoGenJsDir();
		Util.massert(wdir.exists() && wdir.isDirectory(),
			"AutoGen JS Directory does not exist or is not directory %s", wdir);
		
		List<File> hits = Util.filter2list(wdir.listFiles(), f -> CodeGenerator.matchesFileName(this, f));
		Util.massert(hits.size() <= 1, "Found multiple versions of AutoGen JS file : %s", hits);
		
		return hits.isEmpty() ? Optional.empty() : Optional.of(hits.get(0));
	}


	private static Map<WidgetItem, SyncController> __SYNC_MAP = Util.treemap();
	
	static synchronized SyncController getEditController(WidgetItem witem) 
	{
		__maybeDismissOldController();

		__SYNC_MAP.putIfAbsent(witem, new SyncController());

		return __SYNC_MAP.get(witem).registerLoad();
	}

	// TODO: need to implement this at some point.
	// As of Feb 2025, I don't think I have enough tables to really test the behavior here
	private static synchronized void __maybeDismissOldController()
	{


	} 
	
	static class SyncController 
	{
		private int _numLoad = 0;

		private double _lastLoad = Util.curtime();

		SyncController registerLoad() 
		{
			_numLoad++;
			_lastLoad = Util.curtime();
			return this; // Just so we don't need an extra line above
		}
	}
	
	static class ArgMapNumberException extends RuntimeException
	{

		ArgMapNumberException(String colname, String coltype, String inputstr)
		{
			super(getMessage(colname, coltype, inputstr));
		}

		ArgMapNumberException(String colname, ExchangeType coltype, String inputstr)
		{
			super(getMessage(colname, coltype, inputstr));
		}

		private static String getMessage(String colname, Object coltype, String inputstr)
		{
			return String.format("The input string %s could not be converted into a %s, for column %s", inputstr, coltype, colname);
		}

	}
}
