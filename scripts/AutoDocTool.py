#!/usr/bin/python3

import os 
import sys
from datetime import date

import ArgMap
import CodePush
import DataPush
import PullData



def get_running_user():
    
    try:
        return os.getlogin()
    except:
        return "???"

def get_basic_html():

    runuser = get_running_user()
    scriptname =  os.path.basename(sys.argv[0])
    isodate = date.today().isoformat()

    basic =  """
        <p>
        This is the documentation for the Python scripts that are used to 
        communicate with the WebWidgets.io server.
        This information is automatically extracted from the code,
            to prevent documentation rot.
        Text in <code class="doc">code format</code> results from evaluating a code expression.
        </p>

        <p>This data was generated by user <code class="doc">{}</code> on <code class="doc">{}</code>.
        If you are reading this online, please note that you can run this <code class="doc">{}</code> script
            on your local machine as well.
        </li>
    """.format(runuser, isodate, scriptname)

    basic += """
        <p>
        There are three scripts that you can use to push or pull info to the server. 
        They are:
        <ul>
        <li><code class="doc">{}</code></li>
        <li><code class="doc">{}</code></li>
        <li><code class="doc">{}</code></li>
        </ul>
        </p>

        <p>
        The omission of a "PullCode" script is very intentional. Widget developers are expected and empowered
        to backup and manage their source code using whatever methods they prefer
        (source control like Git, DropBox, emailing a zip file to yourself, etc).
        In contrast, the WebWidgets server keeps backups of the DB files on your behalf,
            so you do not need to worry about backing them up unless you are very paranoid
            ("Only the paranoid surive" - Andy Grove).
        </p>

        """.format(PullData.__name__, DataPush.__name__, CodePush.__name__)


    basic += get_requirements()

    basic += get_config()

    basic += get_code_push()

    basic += get_data_push_pull()

    return basic

def get_requirements():

    reqs = """
        <h4>Software Requirements</h4>

        <p>
        These scripts are written in vanilla Python 3 code with no dependencies.
        You should be able to download them from the 
        <a href="https://github.com/comperical/WebWidgets">GitHub repo</a> and run them directly.
        Python is one of the most common programming languages in the world,
            and Python 3 is the modern version, 
            so there is a good chance you already have it.
        To check, run this command:

        <pre>admins-mbp:script burfoot$ python3 --version
Python 3.6.5</pre>

        <p>
        The scripts also depend on <a href="https://curl.se/">curl</a>, 
            a very common utility for transferring data using HTTP.
        To check if you have curl, run:
        </p>

        <pre>admins-mbp:script burfoot$ curl --version
curl 7.64.1 (x86_64-apple-darwin19.0) libcurl/7.64.1 (SecureTransport) LibreSSL/2.8.3 zlib/1.2.11 nghttp2/1.39.2
...</pre>

        <p>
        The WebWidgets framework uses <a href="https://sqlite.org">SQLite</a> (version 3) to store data. 
        SQLite is the most widely deployed database engine in the world.
        To check if you have the right version, type:
        </p>

        <pre>admins-mbp:script burfoot$ sqlite3 --version
3.28.0 2019-04-15 14:49:49 ....
</pre>
        
        <p>Any 3.x version should work fine, you don't need exactly 3.28.0.</p>

    """

    return reqs


def get_code_push():

    codepush = """
        <h4>Pushing Widget Code</h4>

        <p>
        You can push code to the WebWidgets.io server using the <code class="doc">{}</code> script.
        The script takes at least one argument, the name of the widget that you wish to upload.
        The script works by looking up the code directories from the config file,
            and finding a subfolder with the same name as the widget.
        It then zips the contents of the subfolder, and sends the zip file to the server
            using <a href="https://curl.se/">curl<a>.
        The server processes the upload, 
            and emits some log data in response,
            which includes information about the old files being deleted.
        Here is a typical interaction:
        </p>

        <pre>admins-mbp:script burfoot$ CodePush.py widgetname=links
Wrote upload file to path /opt/rawdata/servlet/dburfoot__links.widgetzip
Deleted old file /opt/userdata/widgetserve/dburfoot/links/widget.jsp
Deleted old file /opt/userdata/widgetserve/dburfoot/links/LinkDisplay.js
Extracted file /opt/userdata/widgetserve/dburfoot/links/widget.jsp, size is 11687
Extracted file /opt/userdata/widgetserve/dburfoot/links/LinkDisplay.js, size is 838
Prepended AuthInclude tag to Widget file widget.jsp
        </pre>

    """.format(CodePush.__name__)

    codepush += """
        <p>
        Notice that this upload process is extremely fast.
        The speed of this script means that widgets developers can make use of a very
            simple development process:
            edit a file, push it to the server, and reload to see the result.
        </p>

        <pre>admins-mbp:script burfoot$ time CodePush.py widgetname=links
...
Extracted file /opt/userdata/widgetserve/dburfoot/links/LinkDisplay.js, size is 838
Prepended AuthInclude tag to Widget file widget.jsp

real    0m0.159s
user    0m0.084s
sys     0m0.028s
        </pre>
    """

    return codepush

def get_data_push_pull():

    pushpull = """
        <h4>Pushing / Pulling DB Files</h4>

        <p>
        We also provide scripts for transferring DB data,
            called <code class="doc">{}</code> and <code class="doc">{}</code>.
        These work very similarly to the script for pushing code.
        The main difference is that DB transfers can go both directions,
            which means there is some danger that you will overwrite your data.
        To avoid this situation, we strongly recommend that you avoid keeping your DB files 
            on your local machine for an extended period of time.
        Instead, follow this workflow:
        </p>
    """.format(DataPush.__name__, PullData.__name__)

    pushpull += """

        <ul>
        <li>Start a Widget development session by grabbing one or more DB files</li>
        <li>Make desired changes to the DB file(s) by using the sqlite3 console,
             or whatever DB-access program you prefer</li>
        <li>Upload the modified DB file to the server, and reload the widget</li>
        <li>Continue making changes, uploading, and reloading until you have the desired behavior</li>
        <li>Delete the DB files from your local machine</li>
        </ul>
    """


    pushpull += """
        <p>
        The WebWidgets framework was very intentionally designed to allow and encourage people 
            to use their SQLite databases in a flexible way.
        Many data sources cannot be accessed easily through the browser,
            and therefore Widget JavaScript code cannot get to the data.
        Instead, you might be able to download the data to your local machine.
        Then you can ingest it into your Widget with the following workflow:
        </p>

        <ul>
        <li>Download both the Widget DB and your target data source to your local machine</li>
        <li>Use a Python script (or some other form of software)
            to query the target data, transform it as necessary, and insert it into the Widget DB.</li>
        <li>Upload the Widget DB back to the server</li>
        <li>Use the target data in your Widget with the client-side JavaScript API</li>
        </ul>

    """


    pushpull += """
        <p>
        If you attempt to run <code class="doc">{}</code> but you already have a DB file in the target location,
            the script will give you an error:
        </p>

        <pre>
admins-mbp:script burfoot$ PullData.py widgetname=links 
**Error** : DB path /opt/userdata/db4widget/dburfoot/LINKS_DB.sqlite already exists, please delete or move first, or use deleteold=true</pre>

        <p>
        You can add the extra deleteold argument as suggested, or simply delete the file yourself.
        </p>

        """.format(PullData.__name__)

    pushpull += """
        <p>
        When you upload a DB file, the server inspects the DB schema and regenerates the JavaScript code
            that is used to interface with the Widget framework.
        To demonstrate this, I've added a dummy table to my links database:
        </p>

        <pre>
sqlite> .schema
CREATE TABLE link_main (id int, cat_id int, short_desc varchar(150), link_url varchar(250), primary key(id));
CREATE TABLE link_categ (id int, short_code varchar(20), full_desc varchar(400), is_active smallint, primary key(id));        
sqlite> create table dummy_link (id int, my_link varchar(30), primary key(id));</pre>

        <p>
        Now I upload it to the server, and it creates a new JS file for me.
        The other tables are not changed, so the JS code is not updated.
        </p>

        <pre>
admins-mbp:script burfoot$ DataPush.py widgetname=links
Defaulting to admin user name
Wrote upload file to path /opt/rawdata/servlet/dburfoot__links.sqlite
Saving DB file for widget dburfoot::links
Deleted old DB file /opt/userdata/db4widget/dburfoot/LINKS_DB.sqlite
Copied upload file to location /opt/userdata/db4widget/dburfoot/LINKS_DB.sqlite, size is 26624
Wrote autogen code to path /opt/userdata/widgetserve/dburfoot/autogenjs/links/DummyLink__001.js
New version of AutoGen code identical to previous for DB link_categ
New version of AutoGen code identical to previous for DB link_main</pre>
    """




    return pushpull



def get_config():

    username =  get_running_user()

    topstr = """
        <h4>Configuring the Scripts</h4>

        <p>
        To configure the Python scripts properly, you will need to download a config file and put it in a special folder.
        For example, for the username <code class="doc">{}</code>
        </p>

        <ul>
        <li>Name of subfolder: <code class="doc">{}</code></li>
        <li>User home: <code class="doc">{}</code></li>
        <li><code class="doc">{}</code></li>
        </ul>

    """.format(username, CodePush.SUBFOLDER_NAME, CodePush.get_config_directory(), CodePush.get_widget_config_path(username))


    topstr += """
        <p>
        The contents of this config file are simply a set of key/value pairs.
        The valid keys are:
        </p>
        <ul>
    """

    for key in CodePush.CONFIG_MAP_OKAY_KEYS:
        topstr += """<li><code class="doc">{}</code></li>""".format(key)


    topstr += """
        </ul>

        <p>
        The access hash is a hashed version of your password that the scripts use to authenticate 
        to the server.
        The DB dir is where your SQLite files will go.
        And the codedir1, codedir2 parameters are directories that the system will search for widget code - only
            one of them is necessary.
        </p>
    """

    return topstr

def get_full_html():

    basic = get_basic_html();

    fullstr = """
    <html>
    <style>
        pre {
            font-size: .7em;
            font-family: "Liberation Mono",Menlo,Courier,monospace;
            font-weight: 400;
            padding-top: 3px;
            line-height: 1.42;
            border-radius: 2px;
            padding-bottom: 3px;
            background-color: #e5e5e5;
            color: rgba(0, 0, 0, 0.87);
        }

        code.doc {
            padding: 2px 4px;
            font-size: 80%;
            color: #c7254e;
            background-color: #f9f2f4;
            border-radius: 4px;
            font-family: Menlo,Monaco,Consolas,"Courier New",monospace;
        }

    </style>
    """

    fullstr += """
    <body>

    <center>
    <h3>AutoDoc for WebWidgets Python Code</h3>

    <table width="70%">
    <tr>
    <td>
    {}
    </td>
    </tr>
    </table>
    </body>
    </html>
    """.format(basic)

    return fullstr


if __name__ == "__main__":

    argmap = ArgMap.getFromArgv(sys.argv)
    usefull = argmap.getBit("usefull", True)

    result = get_full_html() if usefull else get_basic_html()
    print(result)
